# 事件循环 - event loop

## 问题：

- 是不是多个微任务会在同一个宏任务中执行，这是JS引擎设定的？

## 大纲

- 常见执行顺序问题 - 
- https://juejin.im/post/5a72df6cf265da3e2c3870b9
- js运行机制 - 单线程 - 为啥是单线程 
- js的事件循环是怎么回事 - 
  - https://blog.csdn.net/Fundebug/article/details/86487117 
  - https://juejin.im/post/5e5c7f6c518825491b11ce93
  - https://juejin.im/post/59e85eebf265da430d571f89
- node中也是js为啥会跟浏览器中的不一样
  - https://mp.weixin.qq.com/s/RNYYNR7A01V-Y2aC1wNsGw
- 微任务 - 宏任务
  - Macro task: setTimeout、MessageChannel、postMessage、setImmediate
  - Micro Task:MutationObsever 和 Promise.then
  - 执行优先级上，主线程任务 > microtask > macrotask
- promise 前身 jQuary中的deffered
- Vue中的事件循环 nextTick是怎么回事 , 与node中的nextTick是否一样 - https://segmentfault.com/a/1190000008589736
- 常见面试题 - setTimeout / promise / await async 执行顺序
- 如何实现js中的多线程 - webworker
- 可以查看事件循环的网站 - http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D 、 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/



# 解释

被称作事件循环的原因在于，同步的任务可能会生成新的任务，因此它一直在不停的查找新的事件并执行。一次循环的执行称之为 tick，在这个循环里执行的代码被称作 task，而整个过程是不断重复的。

```js
console.log(1);

setTimeout(()=>{
  console.log(2);
},1000);

while (true){}
```

上面代码在输出 **1** 之后(谨慎使用！我的浏览器就被卡死了~)，定时器被塞到任务队列里，然后主线程继续往下执行，碰到一个死循环，导致任务队列里的任务永远不会被执行，因此不会输出 **2**

1 4 7 2 3 5 6



调用栈的理解  - 结合try-catch的捕捉机制

```js
function demo() {
    console.log(2)
 }
console.log('demo',  demo())
// 打印顺序
> 2
> demo undefined
```



