参考文章：

[Vue源码](https://xiamijun.github.io/categories/Vue%E6%BA%90%E7%A0%81/)

[Vue源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)

### 源码学习入门

##### 找入口

#### package.json文件

通过package.json的Dev打包配置`"dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev",`，找到配置文件`scripts/config.js`，并且找到`web-full-dev`配置

#### config.js文件

- 地址： `scripts/config.js`
- 找到`web-full-dev`配置

```js
'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  }
// 再根据resolve方法，可以找到入口为`src/platforms/web/entry-runtime-with-compiler.js`
```

##### entry-runtime-with-compiler.js文件

- 地址： `src/platforms/web/entry-runtime-with-compiler.js`

- 拿到核心模块的$mount， 通过**函数劫持**方式进行了拓展，核心就是将模板（如果写了render函数，就不用编译了，如果没写用template属性，再没写就用el）转为render函数
- 通过文件中的  `import Vue from './runtime/index'`  找到下一个文件

#### runtime/index.js 文件

- 地址： `src/platforms/web/runtime/index.js`

- 在 `Vue.prototype`上增加属性和方法

  - ```js
    // install platform patch function
    Vue.prototype.__patch__ = inBrowser ? patch : noop
    // patch函数
    ```

  - 





### 学习思路

- 通过打包看，打包过程，了解整个代码的架构，核心库、平台相关（web, weex, ssr），这些代码是怎么组织的
- 通过断点调试，看执行过程



##  异步更新 -- 这个还是没搞懂 

Dep.notify()

watcher.update()

queueWatcher()

nextTick()

timerFunc()

Watcher.run()



## 虚拟DOM

### 是什么

能够描述真实DOM的js对象，有层级关系

### 为什么需要虚拟DOM

### 调用过程

更新： watcher.run()

updateComponent()

计算虚拟DOM；_render()

更新： _update()

vm._patch__()

patch() 算法的理解

### 调试代码

1. 虚拟DOM的调试

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200321222943689.png" alt="image-20200321222943689" style="zoom:20%;float:left" />

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200321224743812.png" alt="image-20200321224743812" style="zoom:50%;" />

2. 属性更新的调试

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200322003225477.png" alt="image-20200322003225477" style="zoom:23%;" />

### 组件化

**组件**

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200322100536849.png" alt="image-20200322100536849" style="zoom:25%;" />

Options._base 存储的是Vue的构造函数

Vue.extend() 继承做了哪些事

Global-api

组件创建是从父组件到 子组件 ，组件挂载是从子组件到父组件

### 代码层面组件的创建过程 - 没太整明白

最终是调用   

_creatElement方法   路径：src/core/vdom/create-element.js

createComponent方法  路径： src/core/vdom/create-component.js



### 模板编译

主要目标： 将模板template转换为渲染函数render

```js
ƒ anonymous(
) {
with(this){return _c('div',{attrs:{"id":"demo"}},
                     [_c('h1',[_v("Vue模板编译")]),_v(" "),
                      _c('p',[_v(_s(foo))]),_v(" "),
                      _c('comp')],1)}
}
```

_c 就是createElement 返回Vnode

_v 创建文本节点

其他的helpers; 可以在 src/core/instance/render-helpers/index.js

#### 整体流程

1. parse  - 将字符串模板编译为AST（js对象，类似Vnode） ， 变成AST就是为了优化时方便- 转换了下格式
2. optimize - 优化： 静态化,添加static staticRoot *啥时候可以看成是静态的* - 子节点除了text还有其他的不变的节点（如果只有text，没必要标记成静态节点）先标记父节点为静态节点，再去标记子节点，如果所有子节点都是静态节点，那这个父节点就是静态根节点，如果子节点出现不是静态节点，再去修正父节点不是静态根节点
3. generate - 将AST转为代码字符串 ’function（）{}‘
4. compilerToFunction 就是将代码字符串 new Function() 了一下

#### 接下来是v-if v-bind v-model 这些是怎么实现的  - 参照 src/compiler/parser/index.js

核心 ： parseHTML

**v-if**：最终其实就是一个三元表达式， - 参考 src/compiler/parser/index.js 中的parseHTML 中的 processIf（） + src/compiler/codegen/index.js  genIfConditions()

其他的 可以在src/compiler/codegen/index.js中的generate中找到答案



**注意**

v-if v-for 这些指令只能在编译器阶段处理，如果我们在render 函数处理条件或循环只能使用 if for 

最终转化为 博客 或者 视频上传





？？思考内容？？

- [ ]  插槽是如何实现的？
- [ ] 各种指令的实现，最终是怎么处理的

## 作业

- 尝试解答双向绑定实现原理
- 尝试解答事件处理机制
- 继续刷源码，解答开发中的疑惑，写出自己的理解，给大家分享一下更好



