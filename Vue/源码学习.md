参考文章：

[Vue源码](https://xiamijun.github.io/categories/Vue%E6%BA%90%E7%A0%81/)

[Vue源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)

### 源码学习入门

写法

```js
new Vue({
  el: '#app'
  data: {
    
  },
   template: "#demo",
   render(h) { return h(App) }
}).$mount('#app')
```

约定

- 前面加$的属性和方法 是Vue实例上的，暴露给用户使用的 如： this.$data  this.$watch
- 前面加_的属性和方法 是Vue实例上的，内部使用的  如： `this.__init`
- Vue构造函数上的方法 一般啥都不加 如 Vue.use()

### 找Vue的构造函数

#### package.json文件

通过package.json的Dev打包配置`"dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev",`，找到配置文件`scripts/config.js`，并且找到`web-full-dev`配置

#### config.js文件

- 地址： `scripts/config.js`
- 找到`web-full-dev`配置

```js
'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  }
// 再根据resolve方法，可以找到入口为`src/platforms/web/entry-runtime-with-compiler.js`
```

##### entry-runtime-with-compiler.js文件

- 地址： `src/platforms/web/entry-runtime-with-compiler.js`

- 拿到核心模块的$mount， 通过**函数劫持**方式进行了拓展，核心就是将模板（如果写了render函数，就不用编译了，如果没写用template属性，再没写就用el）转为render函数
- 通过文件中的  `import Vue from './runtime/index'`  找到下一个文件

#### runtime/index.js 文件

- 地址： `src/platforms/web/runtime/index.js`

- 在 `Vue.prototype`上增加属性和方法

  - ```js
    // install platform patch function
    Vue.prototype.__patch__ = inBrowser ? patch : noop
    // patch函数
    ```

  - ```js
    // 实现$mount : 挂载组件
    Vue.prototype.$mount = function (el,hydrating): Component {
      el = el && inBrowser ? query(el) : undefined
      // 将模板转为真实DOM后，通过appendChild方法，添加到el元素中
      return mountComponent(this, el, hydrating)
    }
    ```

- 继续通过此文件头部的`import Vue from 'core/index'` 找Vue的构造函数



#### core/index文件

- 地址： `src/core/index.js`

- 初始化全局方法

- ```js
  // 在Vue构造函数上增加方法 - 构建时执行
  initGlobalAPI(Vue)
  // 函数内部都干了啥
  Vue.util = {
      warn,
      extend,
      mergeOptions,
      defineReactive
    }
  Vue.extend()
  Vue.components()
  Vue.filters()
  Vue.set()
  Vue.delete()
  Vue.nextTick()
  Vue.use()
  Vue.mixin()
  ```

- 继续通过此文件头部的`import Vue from './instance/index'` 找Vue的构造函数

#### Instance/index 文件

- 地址： `src/core/instance/index.js`

- 终于找到了 Vue的构造函数

- ```js
  // Vue的构造函数
  function Vue (options) {
    // 执行初始化 - 页面展示的时候执行，也就是new Vue（）的时候执行 -mpy
    this._init(options)
  }
  // 实现了众多的实例属性和方法
  initMixin(Vue) // 扩展了_init 方法
  stateMixin(Vue) // 跟数据状态相关的属性和方法  Vue.prototype.$data/$props/$set/$delete/$watch
  eventsMixin(Vue) // $on/$emit/$once/$off
  lifecycleMixin(Vue) // _update(内部自动更新) / $forceUpdate（外部强制更新） / $destroy（外部强制销毁）
  renderMixin(Vue) // $nextTick / _render
  
  export default Vue
  ```

- 接下来看`_init`方法干了啥，其实看代码可以得知，此方法是执行了`initMixin(Vue)`方法挂到Vue原型上的，接下来我们来看`initMixin`怎么实现的

- 继续通过此文件头部的`import { initMixin } from './init'` 找 `initMixin`方法

#### Instance/init.js文件 - initMixin

- 地址： `src/core/instance/init.js`



### 通过断点调试，理清new Vue()究竟发生了什么，看看Vue组件的一生, 找到我们常看到的那些钩子函数，是在哪里被调用的

#### 首先到Vue的构造函数声明的位置，然后执行了this._init方法

- init方法中都干了啥

- ```js
  
  ```

- 调用了 `beforeCreate` 和 `created` 钩子

#### 然后是 执行$mount方法

- `src/platforms/web/runtime/index.js` 找到 $mount方法，其内部return了 `mountComponent`方法，在顶部我们可以找到 `import { mountComponent } from 'core/instance/lifecycle'`

- 来到 `lifecycle`文件中的`mountComponent`函数，这里重点介绍这个函数

- 这个函数中调用了 `beforeMount`和`mounted`钩子

- ```js
  callHook(vm, 'beforeMount')
  
  updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }
  
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  
  callHook(vm, 'mounted')
  ```

- `updateComponent` 函数中其实就是，调用`__patch__`方法，将VNode渲染成真实DOM挂到el上



## 重回响应式

### initState

- initProps

- initMethods

- initData 方法

  - ```js
      // 遍历data并做响应式处理
      observe(data, true /* asRootData */)
    ```

  - Observe 方法

    - ```js
      
      ```

    - 

- initComputed

- initWatch

一个对象一个ob实例对应一个dep(这个是给数组用的，存储这个数组对象的依赖)，每个key还对应一个dep（这个是对象的key值存储的依赖）

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200813213431088.png" alt="image-20200813213431088" style="zoom:50%;" />

![image-20200813213048014](/Users/mpy/Library/Application Support/typora-user-images/image-20200813213048014.png)

数组的响应式， 就是一个装饰器模式



搞清楚 ob对象都有哪些内容,属性  dep

跑例子 打断点

画出初始化流程思维导图

拓展：Vue.set/ use api 原理







### 学习思路

- 通过打包看，打包过程，了解整个代码的架构，核心库、平台相关（web, weex, ssr），这些代码是怎么组织的
- 通过断点调试，看执行过程
- Vue源码可以分为两大块 
  - 一块是打包的时候运行的  根据将要运行的平台 生成不同的代码 ，也就是我们看到的 dist目录下的这些不同的版本     
  - 一块是项目运行时或者说用户点开页面时 运行的 这部分代码主要是通过我们写在页面中的new Vue触发的 其实他就是执行了一个__init__方法。这里可以通过断点调试，看执行过程



##  异步更新 -- 这个还是没搞懂 

Dep.notify()

watcher.update()

queueWatcher()

nextTick()

timerFunc()

Watcher.run()



## 虚拟DOM

### 是什么

能够描述真实DOM的js对象，有层级关系

### 为什么需要虚拟DOM

### 调用过程

更新： watcher.run()

updateComponent()

计算虚拟DOM；_render()

更新： _update()

vm._patch__()

patch() 算法的理解

### 调试代码

1. 虚拟DOM的调试

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200321222943689.png" alt="image-20200321222943689" style="zoom:20%;float:left" />

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200321224743812.png" alt="image-20200321224743812" style="zoom:50%;" />

2. 属性更新的调试

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200322003225477.png" alt="image-20200322003225477" style="zoom:23%;" />

### 组件化

**组件**

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200322100536849.png" alt="image-20200322100536849" style="zoom:25%;" />

Options._base 存储的是Vue的构造函数

Vue.extend() 继承做了哪些事

Global-api

组件创建是从父组件到 子组件 ，组件挂载是从子组件到父组件

### 代码层面组件的创建过程 - 没太整明白

最终是调用   

_creatElement方法   路径：src/core/vdom/create-element.js

createComponent方法  路径： src/core/vdom/create-component.js



### 模板编译

主要目标： 将模板template转换为渲染函数render

```js
ƒ anonymous(
) {
with(this){return _c('div',{attrs:{"id":"demo"}},
                     [_c('h1',[_v("Vue模板编译")]),_v(" "),
                      _c('p',[_v(_s(foo))]),_v(" "),
                      _c('comp')],1)}
}
```

_c 就是createElement 返回Vnode

_v 创建文本节点

其他的helpers; 可以在 src/core/instance/render-helpers/index.js

#### 整体流程

1. parse  - 将字符串模板编译为AST（js对象，类似Vnode） ， 变成AST就是为了优化时方便- 转换了下格式
2. optimize - 优化： 静态化,添加static staticRoot *啥时候可以看成是静态的* - 子节点除了text还有其他的不变的节点（如果只有text，没必要标记成静态节点）先标记父节点为静态节点，再去标记子节点，如果所有子节点都是静态节点，那这个父节点就是静态根节点，如果子节点出现不是静态节点，再去修正父节点不是静态根节点
3. generate - 将AST转为代码字符串 ’function（）{}‘
4. compilerToFunction 就是将代码字符串 new Function() 了一下

#### 接下来是v-if v-bind v-model 这些是怎么实现的  - 参照 src/compiler/parser/index.js

核心 ： parseHTML

**v-if**：最终其实就是一个三元表达式， - 参考 src/compiler/parser/index.js 中的parseHTML 中的 processIf（） + src/compiler/codegen/index.js  genIfConditions()

其他的 可以在src/compiler/codegen/index.js中的generate中找到答案



**注意**

v-if v-for 这些指令只能在编译器阶段处理，如果我们在render 函数处理条件或循环只能使用 if for 

最终转化为 博客 或者 视频上传





？？思考内容？？

- [ ]  插槽是如何实现的？
- [ ] 各种指令的实现，最终是怎么处理的

## 作业

- 尝试解答双向绑定实现原理
- 尝试解答事件处理机制
- 继续刷源码，解答开发中的疑惑，写出自己的理解，给大家分享一下更好



