

# [可视化分析js的内存分配与回收](https://juejin.im/post/597c5b71f265da3e3d122a3b)

**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存 放在“堆”中的**

**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

### 为什么一定要分”堆“和”栈“两个存储空间呢？

因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态， 如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进 而又影响到整个程序的执行效率。所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类 型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多 大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

```js
// ！！！ 这种理解是错误的 ！！！！
let a =  1
// 上述代码，JS将执行：
// 1. 为变量（a） 创建唯一标识符（identifier）
// 2. 在内存中分配一个地址（在运行时分配）
// 3. 将值1存储在分配的地址 (a 等于内存地址 ‘0012CCWG12’)
let b = a 
// 上述代码，JS将执行：
// 1. 为变量（b） 创建唯一标识符（identifier）
// 2. 将变量a的内存地址赋值给b(b 也等于内存地址 ‘0012CCWG12’)
a = a + 1
// 当 a + 1 解析为2时，JS 将在内存中分配一个新地址，将2作为其值存储，a将指向新地址
// 此时b为多少

let a =  {name: 'mmpy'}
let b = a 
a.name = 'mpy'
// 此时b为多少

```

记住JS中的原始基础数据类型是不可变的

JS 内存模型可以理解为两个不同的区域： **调用栈（call stack）** 和 **堆（heap）**

调用栈是存放原始数据类型的地方(除了函数调用之外)

**堆**是存储引用类型的地方。跟调用栈主要的区别在于，堆可以存储无序的数据，这些数据可以动态地增长，非常适合数组和对象。

![image-20200709110612424](/Users/mpy/Library/Application Support/typora-user-images/image-20200709110612424.png)



### JS 引用类型的变量声明和赋值

`let name = []`

上述代码，在内存中的情况：

1. 为变量创建唯一标识符（“name”）
2. 在内存中分配一个地址（将在运行时分配）
3. 存储在堆上分配的内存地址的值（将在运行时分配）
4. 堆上的内存地址存储分配的值（空数组[]）



### let **vs** const

只有当某个变量将来发生**改变**时才使用let

这里的 **改变**指的是更改内存地址。let允许你更改内存地址，const不允许更改内存地址

```js
let sum = 0
sum = 1 + 2 + 3 + 4 + 5
let numbers = []
numbers.push(1)
numbers.push(2)
numbers.push(3)
numbers.push(4)
numbers.push(5)
// 这里使用let错误地声明了数组 numbers ，因为他将把东西推入数组理解为改变数组的值。实际上这里只是改变数组的值，并没有改变numbers标识符的内存地址指向，完全可以使用const
```

## JS是弱类型、动态语言

弱类型： 隐式转化

动态：声明时可以不指定数据类型

## JS的数据类型

![image-20200711150608459](/Users/mpy/Library/Application Support/typora-user-images/image-20200711150608459.png)





### 内存泄露

函数执行完了，却还有变量没有被回收

#### 项目中遇到的内存泄露有哪些？



### 垃圾回收机制

#### 调用栈中的数据回收

通过**记录当前执行状态的指针**ESP，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保 存在栈中的执行上下文**

#### **堆中的数据是如何回收的**

新生代：福回收期   **Scavenge 算法**  复制  对象晋升策略   对象区域  空闲区域

老生代：住回收器 标记-清除

































































