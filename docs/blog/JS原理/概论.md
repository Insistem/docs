可参考博客；https://github.com/mqyqingfeng/Blog

本文参考：

- 牙羽博客：https://github.com/mqyqingfeng/Blog
- 李兵老师-《浏览器工作原理》
- 《JavaScript 高级程序设计》
- 其他的JS相关底层内容汇总集合： https://github.com/Meqn/store/issues/1
- [闭包](https://github.com/goddyZhao/Translation/blob/master/JavaScript/闭包（closures）.md)

# JS深入专题

### 前言

”执行环境、执行上下文、变量提升、作用域、块级作用域、词法作用域、作用域链、变量对象（VO）、活动对象（AO）、原型链、this指向、闭包、调用栈“，你是否有被JS中的一堆概念整的头晕目眩，貌似都大概知道，但是深究又不知其所以然，看完这篇文章，希望能解答你对这些看似神秘的概念的一些疑惑，follow me, go go!

### 重要概念

#### 执行环境（execution context）也称为作用域

>  定义了变量或函数有权访问的其他数据，以及哪一部分代码可以访问其中的变量，决定了变量的生命周期。每个**执行环境都**有一个与之关联的**变量对象（variable Object， VO）**，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据的时候会在后台使用它。
>
> **全局执行环境**是最外围的一个执行环境。某个执行环境中的所有代码执行完毕后，改环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出-例如关闭网页或浏览器-时才会被销毁）。
>
> 每个函数都有自己的执行环境。当**执行流**（事件循环 eventloop）进入一个函数时，函数的环境就被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正式由这个方便的机制控制着。
>
> 当代码在一个环境中执行时，会创建**变量对象**的一个**作用域链（scope chain）**。其作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object :AO）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象来自下一个包含环境。这样一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
>
> **标识符解析**是沿着作用域链一级一级地搜索**标识符**的过程。搜索过程始终从作用域链的前端开始，然后逐级向后回溯，直至找到标识符为止（如果找不到，通常会导致错误发生）。**变量（注意这里不包含两个特殊的变量：this和arguments）**的访问规则是内部环境是可以通过作用域链从前端开始访问到所有的外部环境，但外部环境不能访问到内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，以查询变量和函数名，但不能通过向下搜索作用域链进入另外一个执行环境。

说明：上文中关于作用域链究竟是怎么连接的，就一句带过”作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象来自下一个包含环境。“，这个官方描述很高大上无法让我们应用到实际的代码分析中，这里我加一个前提，大家应该一下就能明白，作用域链的生成是基于函数的声明位置，而非函数的调用位置，也就是说，你只需要找到函数声明的位置是否有被包含在其他环境中。下面进入实战，上代码！顺便附上一段代码，方便理解作用域链

```js
function bar() {
    var myName = " 小小灶 "
    let test1 = 100
    if (1) {
        let myName = "小马哥 "
        console.log(test)
    }
}
function foo() {
    var myName = " 前端 "
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = " 前端小小灶 "
let myAge = 10
let test = 1
foo()
```

我们画图来分析下作用域链

![image-20200701111703705](/Users/mpy/Library/Application Support/typora-user-images/image-20200701111703705.png)

简而言之：每个函数执行前，先创建一个执行环境，这个执行环境包含两个重要属性：变量对象（用户声明的变量函数+arguments+this）、作用域链，通过作用域链这根绳子串联起来的，这个执行环境包含哪些内容呢，推入调用栈，

#### 

### 变量提升：JS代码执行顺序

### 变量对象（variable Object， VO）、活动对象（activation object，AO）、执行上下文（execution context，EC）

EC： 又叫 执行上下文、执行环境，将 EC 理解成一个对象的话，它有三个属性，一个是变量对象（VO），一个是作用域链（Scope Chain），另一个是this。函数内部的变量的使用就依赖于这个函数执行上下文中的变量对象和作用域链。也就是说，内部函数之所以可以使用外部函数内的变量，之所以可以使用全局变量，都是依赖于当前这个内部函数的执行上下文。

VO：变量对象只是一个抽象的概念，可以通俗的理解成保存当前上下文所有变量的对象。在不同的执行上下文中，它有不同的具体表现。

- 在全局执行上下文中，VO 的具体表现就是全局对象，因为所有的全局变量其实都是全局对象的属性，而VO 的作用是要保存当前上下文中的所有变量，所以此时的变量对象 VO 具体表现就是全局对象。

- 在函数执行上下文中，因为 VO 是要保存当前上下文中所有的变量，一个函数内的变量包括：形参变量、局部变量、自身函数对象引用变量、arguments、this。针对函数执行上下文，为了保存这些变量，特意创建了一个对象，称它为活动对象 AO，函数内所需的变量就都保存在 AO 中，所以此时的变量对象 VO 的具体表现也就是 AO。

- > A variable object (in abbreviated form — VO) is a special object related with an execution context and which stores:
  >
  > - variables (var, VariableDeclaration);
  > - function declarations (FunctionDeclaration, in abbreviated form FD);
  > - and function formal parameters
  >   declared in the context.

  VO 对象包含： 变量声明、函数声明、函数行参（保存在 arguments对象中，该对象有以下属性： callee-对当前函数的引用，length-实参的个数）

参考文章 - VO [https://github.com/goddyZhao/Translation/blob/master/JavaScript/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%EF%BC%88Variable%20object%EF%BC%89.md](https://github.com/goddyZhao/Translation/blob/master/JavaScript/变量对象（Variable object）.md)

### 调用栈 -

#### 调用栈与作用域链的区别？？？ 再加上事件循环 消息队列呢？？

调用栈串起来的是一个个的执行上下文，而作用域链其实保存的是一个个指向执行上下文的变量对象的指针

**调用栈是 JavaScript 引擎追踪函数执行的一个机制**，当一次有多 个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关 系。

一个函数执行时会做两件事，创建自己的执行上下文，1：将其放入一个栈结构的栈顶，栈顶就表示当前执行的代码，如果栈顶是全局执行上下文，表示正在执行全局代码；如果栈顶是函数执行上下文，表示正在执行函数内的代码。当函数执行结束时，这个函数执行上下文就从栈中移出。2：并通过复制自身的[[scope]]（[[]]表示执行引擎为对象创建的内部属性，我们访问不了，也操作不了）属性中的对象构建起执行环境的作用域链（也就是将又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端）

简单来讲作用域链就是为了清晰的控制变量被访问的权限；而调用栈就是记录了一个程序中每个函数被调用的先后顺序（也就是你可以清楚的知道程序是先执行了谁后执行了谁）

​	当JavaScript代码执行一段可执行代码（executable code）时， 会创建对应的执行上下文（execution context）.

对于每个执行上下文，都有三个重要属性

- 变量对象（variable Object， VO）
- 词法环境（let const 声明的变量）
- 作用域链（scope chain）
- this



### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。



### 块级作用域

ES6中的块级作用域有什么特点

Let 没有变量提升，在声明之前调用，会报错

没引入块级作用域之前，容易出现的错误

```js
var myname = 'jike'
function showName() {
    console.log(myname)
    if (0) {
        var myname = 'mmm'
    }
}
showName()
//这里打印的是 undefined 
// var 的作用范围是整个函数
```

通过 let或const 声明的变量会被放到执行上下文的词法环境中。在**词法环境**内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用 域块后，就会把该作用域块内部的变量压到栈顶;当作用域块执行完成之后，该作用域的信息(内部定义的变量)就会从栈顶弹出，这就是词法环境的结构

#### 暂时性死区

```js
let myname = '极客时间'
{
  console.log(myname)
  let myname = '极客邦'
}
// Uncaught ReferenceError: Cannot access 'myname' b efore initialization
在块作用域内，let声明的变量被提升，但变量只是创建被提升，虽然在词法环境中已经存在，但在声明之前使用变量，就会形成一个暂时性死区

let myname = '极客时间'
{
  console.log(myname)
  var myname = '极客邦'
}
// undefined
```



#### JS是如何同时支持var 和let的块级作用域的？

块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合， JavaScript 引擎也就同时支持了变量提升和块级作用域了。

#### 实战- 分析一个for循环的词法环境变化

```js
// 分析下调用栈
for (let i = 0; i < 10; i++) {
    setTimeout(()=>{
         console.log(i)
     })
}

// 分析下调用栈
for (let i = 0; i < 10; i++) {
    setTimeout(function (){
         console.log(i)
     })
}
```

### 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

**词 法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。

### 作用域链和闭包

**作用域链是在函数执行过程中被创建，但是作用域链具体是怎么连接的，是由代码中函数声明的位置决定的**

```js
// 助于理解作用域链的  判断下最终使用的是 counter = 1 还是 counter = 2？？
{
    let counter = 1
    function createCounter() {
        let counter = 2
        const myFunction = function() {
            counter = counter + 1
            return counter
        }
        return myFunction
    }
    const increment = createCounter()
    const c1 = increment()
    const c2 = increment()
    const c3 = increment()
    console.log('example increment', c1, c2, c3)
}
// 闭包理解题1 - 需要注意实参跟形参
 let c = 4
 function addX(x) {
   let n = 6
   return function(n) {
     return n + x   // 这里的n只能取形参n不能取外面的n
   }
 }
const addThree = addX(3)
let d = addThree()
console.log('example partial application', d)
// 闭包理解题2 
 let c = 4
 function addX(x) {
   return function(n) {
     return n + x
   }
 }
const addThree = addX(3)
let d = addThree(4)
console.log('example partial application', d)
```



作用域链串起来的是一个个的执行上下文

```js
// 打印 0、1、2、3....的几种方法
for (var i = 0; i < 10; i++) {
    setTimeout(()=>{
         console.log(i)
     })
}
// 试着解释下这里为什么输出的是
// 方法一 - 闭包
for (var i = 0; i < 10; i++) {
    (function(a){
      setTimeout(()=>{
         console.log(a)
     })
    })(i)
}
// 试着解释下这里为什么输出的是
// 方法二 - 使用let
for (let i = 0; i < 10; i++) {
    setTimeout(()=>{
         console.log(i)
     })
}
// 试着解释下这里为什么输出的是
// 考察了作用域链
？？？ 执行每次循环
```

闭包是指**有权访问**另一个函数作用域中的变量的函数（是代码块和创建该代码块的上下文中数据的结合）。注意这里是 **有权访问**， 而不是访问了。虽然我有权访问但是我不访问，你不能说我不是闭包。如果return了这个函数，那么就是返回函数定义和它的闭包，闭包中包含了创建它时所在作用域内的变量（这里可以理解成外部函数的活动对象不？？？）

当一个基本类型被闭包引用之后，就可以长期存在于内存中，这个时候即使他是基本类型，也是会被存放在堆中的

当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量

一种是可以自动被垃圾回收的闭包，比如内部函数引用了外部函数的变量，虽然构成了闭包，但是因为没有被return出去，函数执行完内部函数也被销毁了，一种是不会自动被回收的闭包，比如 内部函数引用了外部函数的变量，并且这个内部函数被return了出去，

函数套函数，只要满足这种结构就是闭包，其实跟是否return了一个函数；跟内部函数是否使用了外部函数中的变量并没有关系。只不过我们看到的大部分文章举例子都是满足上面的结构，容易让大家误解，并且也确实是写成那种结构，这个闭包才有实际的作用。如下图

```js
// 最常见、最普遍的闭包结构


// 看似不是闭包，但按定义来讲，也是闭包的



// 闭包1
1: let val = 7
 2: function createAdder() {
 3:   function addNumbers(a, b) {
 4:     let ret = a + b
 5:     return ret
 6:   }
 7:   return addNumbers
 8: }
 9: let adder = createAdder()
10: let sum = adder(val, 8)
11: console.log('example of function returning a function: ', sum)
```



当一个函数第一次被调用是，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即[[scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。

后台的每个执行环境都有一个表示变量的对象-变量对象。全局环境的变量对象始终存在，而局部环境的变量对象，只在函数执行的过程中存在。在创建一个函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[scope]]属性中。当调用这个函数时，会为该函数创建一个执行环境，然后通过复制函数的[[scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。显然，作用域链本质上是一个指向变量对象的指针列表，它只是引用但不实际包含变量对象。

一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。

因为闭包保留了对外部环境变量的引用，所以外部环境的活动对象得以在内存中保留，但外部环境的作用域链将会销毁。

闭包只能取得包含函数中任何变量的最后一个值，同一个上下文中创建的闭包是共用一个[[Scope]]属性的， 也就是说，某个闭包对其中的变量做修改会影响到其他闭包对其变量的读取。下面的例子可以说明，因为10个闭包都是引用的同一个变量i，而它只能取得变量i的最后一个值，所以是10个10。

```js
function createFunctions() {
  var result = new Array()
  for(var i=0;i<10;i++) {
    result[i] = function() {
      return i
    }
  }
  return result
}
createFunctions().forEach(e => e()) // 打印10个10
// 为什么？？
```

#### Chrome中查看闭包

<img src="/Users/mpy/Library/Application Support/typora-user-images/image-20200711152354828.png" alt="image-20200711152354828" style="zoom:50%;" />

或者打断点 在scope选项中，可以看到 Closure

> 首先，函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。其次，每次调用函数时，都会(临时)创建一个局部执行上下文。当函数完成时，执行上下文将消失

### this指向

运行时决定的！

this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。

>  在每个函数被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数汇总的这两个变量。

在一般函数调用中，this的值是由激活上下文代码的调用者决定的，一旦激活，this的值就不会被更改

ES6 中的箭头函数并不会创建其自身的执行上下文，所以 箭头函数中的 this 取决于它的外部函数。

>  ![image-20200701170552346](/Users/mpy/Library/Application Support/typora-user-images/image-20200701170552346.png)

至于第三种情况为什么是 the window 可以参考博客 -[从ECMAScript规范解读this]( https://github.com/mqyqingfeng/Blog/issues/7)；[翻译文章：this](https://github.com/goddyZhao/Translation/blob/master/JavaScript/this.md)

[this的各种实际判断场景](https://github.com/ershing/RookieAngle/blob/master/javascript/aboutThis.md)

参考： transition this - https://github.com/goddyZhao/Translation/blob/master/JavaScript/this.md

```js
//全局环境
var a = 10;
var example = {
    a : 20,
    b : function(){
        return this.a;
    }
}
//例子一
console.log(example.b()); //打印结果为20
//例子二
console.log((example.b)()); //打印结果为20
//例子三
console.log((false || example.b)()); //打印结果为10
//例子四
var c = example.b
console.log(c()) // 打印结果是10
看样子 只要运算过拿到的就是函数的地址，就跟例子四一样的效果

// 下面的this指向
let userInfo = {
  name: "jack.ma",
  age: 13,
  sex: 1,
  updateInfo: function() {
    // 模拟 xmlhttprequest 请求延时
    setTimeout(function() {
      this.name = "pony.ma"
      this.age = 39
      this.sex = 123
      console.log(this) // window
    }, 100)
  }
}
userInfo.updateInfo()
// 改成箭头函数 则打印 userInfo
```

最新2019版ECMA标准中的位置

**12.2.10 **The Grouping Operator****

**12.3.4 Function Calls**

**6.2.4 The Reference Specification Type**

关于 赋值操作符的描述 旧版本在 11.13.1 Simple Assignment ( = ):而2019版是在 **12.15.4 Runtime Semantics: Evaluation**

*AssignmentExpression* **:** *LeftHandSideExpression* **=** *AssignmentExpression*



?? : 解释下setTimeout中的函数调用为啥this指向的是window

因为没有这个函数作为变量的方法被调用

### 





#### 基础

变量声明但是没赋值，打印‘undefined’， 没有声明直接调用，打印‘x is not defined’

